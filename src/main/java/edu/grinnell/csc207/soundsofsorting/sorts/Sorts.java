package edu.grinnell.csc207.soundsofsorting.sorts;

import java.util.ArrayList;
import java.util.List;

import edu.grinnell.csc207.soundsofsorting.sortevents.CompareEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;

/**
 * A collection of sorting algorithms.
 * 
 * @param <T>
 */
public class Sorts<T> {
    /**
     * Swaps indices <code>i</code> and <code>j</code> of array <code>arr</code>.
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to swap
     * @param i   the first index to swap
     * @param j   the second index to swap
     */
    public static <T> void swap(T[] arr, int i, int j) {
        T tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * Sorts the array according to the bubble sort algorithm:
     * 
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> List<SortEvent<T>> bubbleSort(T[] arr) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = arr.length - 1; j > 0; j--) {
                comp = new CompareEvent<>(j - 1, j);
                events.add(comp);
                if (arr[j].compareTo(arr[j - 1]) < 0) {
                    swap(arr, j - 1, j);
                    swap = new SwapEvent<>(j - 1, j);
                    events.add(swap);
                }
            }
        }
        return events;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * 
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> List<SortEvent<T>> selectionSort(
            T[] arr) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = 0; i < arr.length; i++) {
            T min = arr[i];
            int index = i;
            for (int j = i; j < arr.length; j++) {
                comp = new CompareEvent<>(i, j);
                events.add(comp);
                if (min.compareTo(arr[j]) > 0) {
                    min = arr[j];
                    index = j;
                }
            }
            swap(arr, i, index);
            swap = new SwapEvent<>(i, index);
            events.add(swap);
        }
        return events;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * 
     * <pre>
     * [ i elements in order | unprocessed ]
     * </pre>
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> List<SortEvent<T>> insertionSort(
            T[] arr) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        List<SortEvent<T>> events = new ArrayList<>();

        for (int i = 0; i < arr.length - 1; i++) {
            int j = i + 1;
            while (j > 0 && arr[j].compareTo(arr[j - 1]) < 0) {
                comp = new CompareEvent<>(j, j - 1);
                events.add(comp);
                swap(arr, j, j - 1);
                swap = new SwapEvent<>(j, j - 1);
                events.add(swap);
                j--;
            }
        }
        return events;
    }

    /**
     * A helper function to sort the broken down lists for merge sort.
     * 
     * @param <T>    Type T
     * @param arr    : The array being sorted
     * @param hiOne  int: the right side of the first array
     * @param lowOne int: the left side of the first array
     * @param hiTwo  int: The right side of the second array
     * @param lowTwo int: The left side of the second array
     * @param events list: The list of sort events.
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> void mergeHelper(T[] arr, int hiOne, int lowOne,
            int hiTwo, int lowTwo, List<SortEvent<T>> events) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        events = new ArrayList<>();

        for (int i = lowOne; i < hiTwo; i++) {
            for (int j = i + 1; j < hiTwo; j++) {
                comp = new CompareEvent<>(i, j);
                events.add(comp);
                if (arr[i].compareTo(arr[j]) > 0) {
                    swap(arr, i, j);
                    swap = new SwapEvent<>(i, j);
                    events.add(swap);
                }
            }
        }

    }

    /**
     * A helper functions that breaks the main list down into a bunch of lists
     * 
     * @param <T>    Type T
     * @param arr    : The array being sorted
     * @param hi     int: the right side of the array
     * @param low    int: the left side of the array
     * @param events list: the list of events
     */
    public static <T extends Comparable<? super T>> void mergeSortHelper(T[] arr, int hi, int low,
            List<SortEvent<T>> events) {
        int mid = low + (hi - low) / 2;
        if (low < mid) {
            mergeSortHelper(arr, mid, low, events);
        }
        if (hi > mid + 1) {
            mergeSortHelper(arr, hi, mid, events);
        }
        mergeHelper(arr, mid, low, hi, mid, events);
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> mergeSort(
            T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();
        mergeSortHelper(arr, arr.length, 0, events);

        return events;
    }

    /**
     * Finds the median value for quick sort
     * 
     * @param <T>    Type T
     * @param arr    : The array being sorted
     * @param hi     int: The right side of the array
     * @param low    int: The left side of the array
     * @param events list: The list of sort events
     * @return int: The med value
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> int medValue(T[] arr, 
        int hi, int low, List<SortEvent<T>> events) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        T med = arr[low];
        int i = low - 1;
        int j = hi + 1;

        while (true) {
            do {
                i++;
                comp = new CompareEvent<>(i, j - 1);
                events.add(comp);
            } while (arr[i].compareTo(med) < 0 && i <= hi);

            do {
                j--;
                comp = new CompareEvent<>(i, j);
                events.add(comp);
            } while (arr[j].compareTo(med) > 0 && j >= low);

            if (i >= j) {
                return j;
            }

            swap(arr, i, j);
            swap = new SwapEvent<>(i, j);
            events.add(swap);
        }

    }

    /**
     * A helper function that breaks down the array for quick sort
     * 
     * @param <T>
     * @param arr    : The array being sorted
     * @param hi     int: the right side of the array
     * @param low    int: the left side of the array
     * @param events list: The list of sort events
     */
    public static <T extends Comparable<? super T>> void quickSortHelper(T[] arr, int hi, int low,
            List<SortEvent<T>> events) {
        if (hi > low && low >= 0 && hi >= 0) {
            int med = medValue(arr, hi, low, events);
            quickSortHelper(arr, med, low, events);
            quickSortHelper(arr, hi, med + 1, events);
        }
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<T>> quickSort(T[] arr) {
        List<SortEvent<T>> events = new ArrayList<>();
        quickSortHelper(arr, arr.length - 1, 0, events);
        return events;
    }

    /**
     * Sorts the array according to the exchange sort algorithm.
     * 
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    @SuppressWarnings("unchecked")
    public static <T extends Comparable<? super T>> List<SortEvent<T>> exchangeSort(T[] arr) {
        @SuppressWarnings("rawtypes")
        SwapEvent swap = new SwapEvent<>(0, 0);
        @SuppressWarnings("rawtypes")
        CompareEvent comp = new CompareEvent<>(0, 0);
        List<SortEvent<T>> events = new ArrayList<>();
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                comp = new CompareEvent<>(i, j);
                events.add(comp);
                if (arr[i].compareTo(arr[j]) > 0) {
                    swap(arr, i, j);
                    swap = new SwapEvent<>(i, j);
                    events.add(swap);
                }
            }
        }
        return events;
    }

    /**
     * Given an array of T and list of SortEvent<T> objects, apply those evens to the list in order
     * 
     * @param <T>    Type T
     * @param l      array: That events are being applied to
     * @param events list: The list of events
     */
    public static <T> void eventSort(T[] l, List<SortEvent<T>> events) {
        for (int i = 0; i < events.size(); i++) {
            events.get(i).apply(l);
        }
    }

}
